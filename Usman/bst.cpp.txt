#include<iostream>
#include<stack>
using namespace std;

class node
{
public:
	int data;
	node* left, * right;
	node()
	{
		left = right = NULL;
	}
};

class BST
{
private:
	node* root;
	int count;
public:
	BST()
	{
		root = NULL;
		count = 0;
	}
	~BST()
	{
		deleteTree(getRoot());
	}

	void deleteTree(node* treeRoot)
	{
		if (treeRoot == NULL || treeRoot->left == NULL || treeRoot->right == NULL)
			return;
		deleteTree(treeRoot->right);
		deleteTree(treeRoot->left);
		delete treeRoot;
		treeRoot = nullptr;
	}
	bool search(int value)
	{
		node* traverse = root;
		while (traverse)
		{
			//value found in the tree
			if (traverse->data == value)
				return true;
			//goes to left subtree if value is smaller than current root node
			if (value < traverse->data)
				traverse = traverse->left;
			//goes to right subtree if value is greater than current root node
			else
				traverse = traverse->right;
		}
		//returns false if value is not found in the tree
		return false;
	}
	void insert(int value)
	{
		//first check for duplicates
		if (search(value))
		{
			cout << "Value already exists in the tree!" << endl
				<< "Duplicates cannot be inserted!" << endl;
			return;
		}
		count++;
		//creating a node
		node* newNode = new node();
		newNode->left = newNode->right = NULL;
		newNode->data = value;
		if (root == NULL)
		{
			root = newNode;
			cout << "Node has been inserted successfully!" << endl;
			return;
		}
		node* traverse = root;
		while (true) //infinite loop until node is inserted
		{
			if (value < traverse->data)
			{
				if (traverse->left != NULL)
					traverse = traverse->left;
				else
				{
					traverse->left = newNode;
					cout << "Node has been inserted successfully!" << endl;
					return;
				}
			}
			else if (value > traverse->data)
			{
				if (traverse->right != NULL)
					traverse = traverse->right;
				else
				{
					traverse->right = newNode;
					cout << "Node has been inserted successfully!" << endl;
					return;
				}
			}
		}
	}
	void deleteNode(int value)
	{
		bool found = false;
		node* traverse = root;
		if (!root)
		{
			cout << "TREE IS EMPTY!" << endl;
			return;
		}
		while (traverse)
		{
			//value found in the tree
			if (traverse->data == value)
			{
				found = true;
				break;
			}
			//goes to left subtree if value is smaller than current root node
			if (value < traverse->data)
				traverse = traverse->left;
			//goes to right subtree if value is greater than current root node
			else
				traverse = traverse->right;
		}
		//returns if value is not found in the tree
		if (!found)
		{
			cout << "Value doesn't exist in the tree!" << endl;
			return;
		}
		node* temp;
		//case for one left child
		if (traverse->right == NULL)
		{
			temp = traverse;
			traverse = traverse->left; //reattaching the left child
			delete temp;
			temp = nullptr;
		}
		//case for one right child
		else	if (traverse->left == NULL)
		{
			temp = traverse;
			traverse = traverse->right; //reattaching the right child
			delete temp;
			temp = nullptr;
		}
		//case for two children
		else
		{
			temp = traverse->right;
			while (temp->left)
				temp = temp->left;
			temp->left = traverse->left;
			temp = traverse;
			traverse = traverse->right;
			delete temp;
			temp = nullptr;
		}
		cout << value << " has been deleted from the BST Tree!" << endl;
	}
	void inorder_traversal(node* traverse) //for in-order traversal to display the tree
	{
		if (traverse == NULL)
			return;
		inorder_traversal(traverse->left);
		cout << traverse->data << " ";
		inorder_traversal(traverse->right);
	}
	void preorder_traversal(node* traverse) //for preorder traversal to display the tree
	{
		stack <node*> s1;
		if (traverse == NULL)
			return;
		s1.push(root);
		node* curr = NULL;
		while (!s1.empty())
		{
			curr = s1.top();
			cout << curr->data << " ";
			s1.pop();

			if (curr->right)
				s1.push(curr->right);
			if (curr->left)
				s1.push(curr->left);
		}
	}
	void postorder_traversal(node* traverse) //for postorder traversal to display the tree
	{
		stack <node*> s1;
		if (traverse == NULL)
			return;
		node* curr = root;
		node* prev = NULL;
		while (curr || !s1.empty())
		{
			if (curr)
			{
				s1.push(curr);
				curr = curr->left;
			}
			else
			{
				curr = s1.top();
				if (!curr->right || curr->right == prev)
				{
					cout << curr->data << " ";
					s1.pop();
					prev = curr;
					curr = NULL;
				}
				else
					curr = curr->right;
			}
		}
	}
	void ancestors(node* traverse, int value)
	{
		if (!search(value))
		{
			cout << "Value doesn't exist in the tree!" << endl;
			return;
		}
		cout << "-----DISPLAYING ALL ANCESTORS OF " << value << "----- " << endl;
		while (traverse)
		{
			//value found in the tree
			if (traverse->data == value)
			{
				cout << traverse->data << endl;
				return;
			}
			//goes to left subtree if value is smaller than current root node
			if (value < traverse->data)
			{
				cout << traverse->data << " ";
				traverse = traverse->left;
			}
			//goes to right subtree if value is greater than current root node
			else
			{
				cout << traverse->data << " ";
				traverse = traverse->right;
			}
		}
	}
	int total_number_of_leaf_nodes(node* p)
	{
		if (p == NULL)
			return 0;
		if (p->left == NULL && p->right == NULL)
			return 1;
		else
			return 	 (total_number_of_leaf_nodes(p->left) + total_number_of_leaf_nodes(p->right));
	}
	void nodesAtHeight(int height)
	{
		if (root)
		{
			int num = 1;
			while (height > 0)
			{
				num = num * 2;
				height--;
			}
			cout << "Total number of nodes at this height are: " << num << endl;
		}
		else
			cout << "Tree is empty!" << endl;
	}
	void largest()
	{
		int large = 0;
		node* temp = root;
		while (temp)
		{
			large = temp->data;
			temp = temp->right;
		}
		cout << "Largest value in BST tree: " << large << endl;
	}
	void smallest()
	{
		int small = 0;
		node* temp = root;
		while (temp)
		{
			small = temp->data;
			temp = temp->left;
		}
		cout << "Smallest value in BST tree: " << small << endl;
	}
	node* getRoot()
	{
		return root;
	}
};
int main()
{
	BST tree;
	int choice;
	int value;
	do
	{
		cout << "Press 0 to exit" << endl
			<< "Press 1 to insert a node in BST" << endl
			<< "Press 2 to delete a node from BST" << endl
			<< "Press 3 to search a specific node in BST" << endl
			<< "Press 4 to display all nodes (in-order traversal)" << endl
			<< "Press 5 to display all nodes (pre-order traversal)" << endl
			<< "Press 6 to display all nodes (post-order traversal)" << endl
			<< "Press 7 to display all the ancestors of a node" << endl
			<< "Press 8 to count the number of leaf nodes in BST Tree" << endl
			<< "Press 9 to find the largest value in BST" << endl
			<< "Press 10 to find the smallest value in BST" << endl
			<<"Press 11 to count the number of nodes at a particular height"<<endl
			<< "Enter choice: ";
		cin >> choice;
		switch (choice)
		{
		default:
		{
			cout << "Invalid input!" << endl;
			break;
		}
		case 0:
		{
			cout << "Exiting the program..............." << endl;
			system("pause");
			return 0;
			break;
		}
		case 1:
		{
			cout << "Enter a value to insert in BST: ";
			cin >> value;
			tree.insert(value);
			break;
		}
		case 2:
		{
			cout << "Enter a value to delete from BST: ";
			cin >> value;
			tree.deleteNode(value);
			break;
		}
		case 3:
		{
			cout << "Enter a value to search in BST: ";
			cin >> value;
			if (tree.search(value))
				cout << "Value found in the tree" << endl;
			else
				cout << "Value doesn't exist in the tree!" << endl;
			break;
		}
		case 4:
		{
			node* ptr = tree.getRoot();
			cout << "-----DISPLAYING ALL NODES IN BST THROUGH IN-ORDER TRAVERSAL-----" << endl;
			tree.inorder_traversal(ptr);
			cout << endl;
			break;
		}
		case 5:
		{
			node* ptr = tree.getRoot();
			cout << "-----DISPLAYING ALL NODES IN BST THROUGH PRE-ORDER TRAVERSAL-----" << endl;
			tree.preorder_traversal(ptr);
			cout << endl;
			break;
		}
		case 6:
		{
			node* ptr = tree.getRoot();
			cout << "-----DISPLAYING ALL NODES IN BST THROUGH POST-ORDER TRAVERSAL-----" << endl;
			tree.postorder_traversal(ptr);
			cout << endl;
			break;
		}
		case 7:
		{
			cout << "Enter the value of a node to see all of its ancestors: ";
			cin >> value;
			node* ptr = tree.getRoot();
			tree.ancestors(ptr, value);
			break;
		}
		case 8:
		{
			node* ptr = tree.getRoot();
			cout << "Total leaf nodes: " << tree.total_number_of_leaf_nodes(ptr) << endl;
			break;
		}
		case 9:
		{
			tree.largest();
			break;
		}
		case 10:
		{
			tree.smallest();
			break;
		}
		case 11:
		{
			cout << "Enter height at which you want to count the number of nodes: ";
			cin >> value;
			tree.nodesAtHeight(value);
			break;
		}
		}
		system("pause");
		system("cls");
	} while (choice != 0);
	system("pause");
	return 0;
}
